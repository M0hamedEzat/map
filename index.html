<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Campus Navigator - Interactive Pathfinding</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1800px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .main-content {
        display: grid;
        grid-template-columns: 380px 1fr;
        gap: 0;
        min-height: 800px;
      }

      .sidebar {
        background: #f8f9fa;
        padding: 25px;
        border-right: 2px solid #e0e0e0;
        overflow-y: auto;
        max-height: 900px;
      }

      /* Mobile Styles */
      @media (max-width: 768px) {
        body {
          padding: 0;
        }

        .container {
          border-radius: 0;
        }

        .header h1 {
          font-size: 1.8em;
        }

        .header p {
          font-size: 0.9em;
        }

        .main-content {
          grid-template-columns: 1fr;
          min-height: auto;
        }

        .sidebar {
          border-right: none;
          border-bottom: 2px solid #e0e0e0;
          max-height: none;
          padding: 15px;
        }

        .control-section {
          padding: 15px;
          margin-bottom: 15px;
        }

        .map-container {
          min-height: 400px;
          height: 60vh;
        }

        .zoom-controls {
          top: 10px;
          right: 10px;
          gap: 8px;
        }

        .zoom-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }

        .legend {
          padding: 10px;
        }

        .legend h4 {
          font-size: 12px;
        }

        .legend-item {
          font-size: 11px;
          gap: 8px;
        }

        .direction-step {
          padding: 10px;
          gap: 8px;
        }

        .step-number {
          width: 25px;
          height: 25px;
          font-size: 12px;
        }

        .step-text {
          font-size: 13px;
        }
      }

      /* Small Mobile Styles */
      @media (max-width: 480px) {
        .header {
          padding: 20px 15px;
        }

        .header h1 {
          font-size: 1.5em;
        }

        .sidebar {
          padding: 10px;
        }

        .control-section {
          padding: 12px;
        }

        .btn {
          padding: 12px;
          font-size: 14px;
        }

        .zoom-btn {
          width: 35px;
          height: 35px;
          font-size: 16px;
        }

        .map-container {
          min-height: 300px;
          height: 50vh;
        }
      }

      .btn-compass {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .btn-compass:disabled {
        background: linear-gradient(135deg, #a8b3f0 0%, #b89ac9 100%);
      }
      /* Compass Styles - Google Maps Style */
      .compass-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .compass {
        width: 50px;
        height: 50px;
        position: relative;
        background: white;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .compass:hover {
        transform: scale(1.05);
      }

      .compass-inner {
        width: 100%;
        height: 100%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .compass-pointer {
        position: absolute;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 24px solid #4285f4;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -70%);
        transform-origin: 50% 70%;
        transition: transform 0.3s ease-out;
        filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.3));
      }

      .compass-pointer::after {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 18px solid #ea4335;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
      }

      .compass-center-dot {
        position: absolute;
        width: 8px;
        height: 8px;
        background: white;
        border: 2px solid #5f6368;
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .compass-label {
        font-size: 11px;
        font-weight: 500;
        color: #5f6368;
        background: white;
        padding: 4px 8px;
        border-radius: 12px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        white-space: nowrap;
      }

      .compass-error {
        color: #ea4335;
        font-size: 10px;
      }

      @media (max-width: 768px) {
        .compass-container {
          bottom: 80px;
          right: 10px;
        }

        .compass {
          width: 45px;
          height: 45px;
        }

        .compass-pointer {
          border-left: 7px solid transparent;
          border-right: 7px solid transparent;
          border-bottom: 20px solid #4285f4;
        }

        .compass-pointer::after {
          border-left: 5px solid transparent;
          border-right: 5px solid transparent;
          border-top: 15px solid #ea4335;
        }

        .compass-label {
          font-size: 10px;
          padding: 3px 6px;
        }
      }

      .map-container {
        position: relative;
        background: #fafafa;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .control-section {
        margin-bottom: 20px;
        padding: 20px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .control-section h3 {
        color: #667eea;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      .input-group {
        margin-bottom: 15px;
      }

      .input-group label {
        display: block;
        margin-bottom: 5px;
        color: #555;
        font-weight: 600;
        font-size: 14px;
      }

      select,
      input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 15px;
        transition: border-color 0.3s;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        width: 100%;
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        margin-top: 10px;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .directions {
        margin-top: 15px;
        max-height: 400px;
        overflow-y: auto;
      }

      .direction-step {
        padding: 12px;
        background: white;
        border-left: 4px solid #667eea;
        margin-bottom: 10px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .step-number {
        background: #667eea;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        flex-shrink: 0;
        font-size: 14px;
      }

      .step-text {
        flex: 1;
        font-size: 14px;
      }

      .step-distance {
        color: #888;
        font-size: 0.85em;
        font-weight: 600;
      }

      .total-distance {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      canvas {
        display: block;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .zoom-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 100;
      }

      .zoom-btn {
        width: 45px;
        height: 45px;
        background: white;
        border: 2px solid #667eea;
        border-radius: 8px;
        font-size: 20px;
        font-weight: bold;
        color: #667eea;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.2s;
      }

      .zoom-btn:hover {
        background: #667eea;
        color: white;
        transform: scale(1.1);
      }

      .legend {
        background: white;
        padding: 15px;
        border-radius: 8px;
      }

      .legend h4 {
        margin-bottom: 10px;
        color: #667eea;
        font-size: 14px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        font-size: 13px;
      }

      .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #333;
      }

      .legend-line {
        width: 30px;
        height: 4px;
        border-radius: 2px;
      }

      .message {
        padding: 12px;
        border-radius: 8px;
        margin-top: 10px;
        font-size: 14px;
        display: none;
      }

      .error-message {
        background: #ff4444;
        color: white;
      }

      .success-message {
        background: #00c851;
        color: white;
      }

      .info-message {
        background: #33b5e5;
        color: white;
      }

      .file-upload-section {
        background: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 2px dashed #667eea;
      }

      .file-upload-section h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .upload-btn {
        background: #667eea;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        margin: 5px 0;
        width: 100%;
      }

      .upload-btn:hover {
        background: #5568d3;
      }

      .file-name {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>🗺️ Campus Navigator</h1>
        <p>Find the shortest path between any two locations</p>
      </div>

      <div class="main-content">
        <div class="sidebar">
          <!-- File Upload Section (Optional - files auto-load) -->
          <div class="file-upload-section" id="uploadSection" style="display: none;">
            <h3>📁 Load Different Map (Optional)</h3>
            <label for="graphFile" class="upload-btn"
              >1. Select Graph JSON File</label
            >
            <input
              type="file"
              id="graphFile"
              accept=".json"
              style="display: none"
            />
            <div class="file-name" id="graphFileName">No file selected</div>

            <label for="imageFile" class="upload-btn" style="margin-top: 10px"
              >2. Select Floor Plan Image</label
            >
            <input
              type="file"
              id="imageFile"
              accept="image/*"
              style="display: none"
            />
            <div class="file-name" id="imageFileName">No file selected</div>
          </div>

          <!-- Route Selection -->
          <div class="control-section" id="routeSection">
            <h3>📍 Select Your Route</h3>

            <div class="input-group">
              <label for="startNode">Starting Point:</label>
              <select id="startNode">
                <option value="">-- Select Start --</option>
              </select>
            </div>

            <div class="input-group">
              <label for="endNode">Destination:</label>
              <select id="endNode">
                <option value="">-- Select Destination --</option>
              </select>
            </div>

            <button class="btn" id="findPathBtn" onclick="findPath()">
              🚀 Find Shortest Path
            </button>

            <button class="btn btn-secondary" onclick="clearPath()">
              🔄 Clear Path
            </button>

            <button class="btn btn-compass" id="compassBtn" onclick="enableCompass()" style="display: none;">
              🧭 Enable Compass
            </button>

            <div class="message error-message" id="errorMessage"></div>
            <div class="message success-message" id="successMessage"></div>
          </div>

          <!-- Directions -->
          <div
            class="control-section"
            id="directionsSection"
            style="display: none"
          >
            <h3>📋 Turn-by-Turn Directions</h3>
            <div class="total-distance" id="totalDistance"></div>
            <div class="directions" id="directionsList"></div>
          </div>

          <!-- Legend -->
          <div class="control-section">
            <div class="legend">
              <h4>Legend:</h4>
              <div class="legend-item">
                <div class="legend-color" style="background: #4caf50"></div>
                <span>Start Point</span>
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #f44336"></div>
                <span>Destination</span>
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #ff9800"></div>
                <span>Waypoint</span>
              </div>
              <div class="legend-item">
                <div class="legend-line" style="background: #2196f3"></div>
                <span>Shortest Path</span>
              </div>
            </div>
          </div>
        </div>

        <div class="map-container">
          <div class="zoom-controls" id="zoomControls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="zoomReset()">⊙</button>
            <button class="zoom-btn" onclick="zoomOut()">−</button>
          </div>

                    
          <!-- Compass -->
          <div class="compass-container" id="compassContainer">
            <div class="compass" id="compass" title="Compass">
              <div class="compass-inner">
                <!-- Blue pointer arrow pointing North -->
                <div class="compass-pointer" id="compassPointer"></div>
                
                <!-- Center dot -->
                <div class="compass-center-dot"></div>
              </div>
            </div>
            <div class="compass-label" id="compassLabel">---</div>
          </div>


          <canvas id="mapCanvas"></canvas>
          <div
            class="message info-message"
            id="infoMessage"
            style="
              position: absolute;
              display: none;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              padding: 30px;
              font-size: 16px;
            "
          >
            Loading map...
          </div>
        </div>
      </div>
    </div>

    <!-- Load graph data as JavaScript -->
    <script src="graph_data.js"></script>

    <script>
      // ==================== DIJKSTRA'S ALGORITHM ====================
      class PriorityQueue {
        constructor() {
          this.values = [];
        }

        enqueue(val, priority) {
          this.values.push({ val, priority });
          this.sort();
        }

        dequeue() {
          return this.values.shift();
        }

        sort() {
          this.values.sort((a, b) => a.priority - b.priority);
        }

        isEmpty() {
          return this.values.length === 0;
        }
      }

      function dijkstra(graph, start, end) {
        const distances = {};
        const previous = {};
        const pq = new PriorityQueue();

        // Initialize distances
        for (let node in graph) {
          distances[node] = Infinity;
          previous[node] = null;
        }
        distances[start] = 0;
        pq.enqueue(start, 0);

        while (!pq.isEmpty()) {
          const { val: currentNode } = pq.dequeue();

          if (currentNode === end) {
            // Build path
            const path = [];
            let current = end;
            while (current !== null) {
              path.unshift(current);
              current = previous[current];
            }
            return { path, distance: distances[end] };
          }

          if (graph[currentNode]) {
            for (let neighbor in graph[currentNode]) {
              const weight = graph[currentNode][neighbor];
              const newDistance = distances[currentNode] + weight;

              if (newDistance < distances[neighbor]) {
                distances[neighbor] = newDistance;
                previous[neighbor] = currentNode;
                pq.enqueue(neighbor, newDistance);
              }
            }
          }
        }

        return { path: [], distance: Infinity };
      }

      // ==================== GLOBAL VARIABLES ====================
      const canvas = document.getElementById("mapCanvas");
      const ctx = canvas.getContext("2d");

      let graphData = null;
      let adjacencyList = {};
      let backgroundImage = null;
      let currentPath = [];
      let currentPathDistance = 0;
      let baseToVariants = {};

      // Zoom and pan
      let scale = 1;
      let offsetX = 0;
      let offsetY = 0;
      let isPanning = false;
      let hasPanned = false;
      let startPanX = 0;
      let startPanY = 0;

      // Node colors by type
      const nodeColors = {
        entrance: "#FF6B6B",
        hallway: "#4ECDC4",
        room: "#95E1D3",
        elevator: "#FFD93D",
        stairs: "#FFA07A",
        restroom: "#DDA0DD",
        outdoor: "#90EE90",
        building: "#FFB6C1",
        classroom: "#87CEEB",
      };

      // ==================== AUTO-LOAD FILES ON PAGE LOAD ====================
      window.addEventListener('load', async () => {
        try {
          // Use embedded graph data from graph_data.js
          graphData = GRAPH_DATA;
          buildAdjacencyList();
          populateDropdowns();
          console.log('✅ Graph data loaded');

          // Load background image
          const img = new Image();
          img.onload = () => {
            backgroundImage = img;
            canvas.width = img.width;
            canvas.height = img.height;
            setupCanvasControls();
            draw();
            console.log('✅ Map image loaded');
            checkIfReady();
          };
          img.onerror = () => {
            alert('Error loading Map.jpg. Make sure the file exists in the same directory.');
          };
          img.src = 'Map.jpg';
        } catch (error) {
          console.error('Error loading files:', error);
          alert('Error loading map. Make sure graph_data.js and Map.jpg are in the same directory.');
        }
      });

      // ==================== OPTIONAL FILE UPLOAD HANDLERS ====================
      document
        .getElementById("graphFile")
        .addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (file) {
            const text = await file.text();
            graphData = JSON.parse(text);
            buildAdjacencyList();
            populateDropdowns();
            document.getElementById(
              "graphFileName"
            ).textContent = `✅ ${file.name}`;
            checkIfReady();
          }
        });

      document.getElementById("imageFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              backgroundImage = img;
              canvas.width = img.width;
              canvas.height = img.height;
              document.getElementById(
                "imageFileName"
              ).textContent = `✅ ${file.name}`;
              checkIfReady();
              setupCanvasControls();
              draw();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      function checkIfReady() {
        if (graphData && backgroundImage) {
          document.getElementById("uploadSection").style.display = "none";
          document.getElementById("routeSection").style.display = "block";
          document.getElementById("zoomControls").style.display = "flex";
          document.getElementById("infoMessage").style.display = "none";
        }
      }

      // ==================== BUILD ADJACENCY LIST ====================
      function buildAdjacencyList() {
        adjacencyList = {};

        // Initialize all nodes
        graphData.nodes.forEach((node) => {
          adjacencyList[node.id] = {};
        });

        // Add edges (bidirectional)
        graphData.edges.forEach((edge) => {
          adjacencyList[edge.source][edge.target] = edge.weight;
          // Assuming undirected graph
          adjacencyList[edge.target][edge.source] = edge.weight;
        });
      }

      // ==================== POPULATE DROPDOWNS ====================
      
      function populateDropdowns() {
        // Build base -> variants map
        baseToVariants = {};
        graphData.nodes.forEach((node) => {
          const id = node.id;
          // treat trailing 'a' or 'b' (case-insensitive) as a door suffix
          const lastChar = id.slice(-1);
          let baseId = id;
          if (/^[ab]$/i.test(lastChar) && /^[A-Za-z0-9]+[abAB]$/.test(id)) {
            baseId = id.slice(0, -1);
          }
          if (!baseToVariants[baseId]) baseToVariants[baseId] = [];
          baseToVariants[baseId].push(id);
        });

        const startSelect = document.getElementById("startNode");
        const endSelect = document.getElementById("endNode");

        // Reset selects
        startSelect.innerHTML = '<option value="">-- Select Start --</option>';
        endSelect.innerHTML = '<option value="">-- Select Destination --</option>';

        // Sort base IDs
        const sortedBases = Object.keys(baseToVariants).sort((a, b) =>
          a.localeCompare(b)
        );

        sortedBases.forEach((baseId) => {
          // Skip bases that start with 'H'
          if (baseId.startsWith("H")) return;

          const variantSample = graphData.nodes.find(
            (n) => n.id === baseToVariants[baseId][0]
          );
          const displayText = variantSample && variantSample.type
            ? `${baseId} (${variantSample.type})`
            : baseId;

          const option1 = document.createElement("option");
          option1.value = baseId;
          option1.textContent = displayText;
          startSelect.appendChild(option1);

          const option2 = option1.cloneNode(true);
          endSelect.appendChild(option2);
        });
      }

      // ==================== FIND PATH ====================
     
      function findPath() {
        const startNode = document.getElementById("startNode").value;
        const endNode = document.getElementById("endNode").value;

        // Validation
        if (!startNode || !endNode) {
          showMessage(
            "error",
            "Please select both start and destination points"
          );
          return;
        }

        if (startNode === endNode) {
          showMessage("error", "Start and destination cannot be the same");
          return;
        }

        // Resolve selected base IDs to actual variant node IDs
        const startCandidates = baseToVariants[startNode]
          ? [...baseToVariants[startNode]]
          : [startNode];
        const endCandidates = baseToVariants[endNode]
          ? [...baseToVariants[endNode]]
          : [endNode];

        // Try all combinations and pick the shortest resulting path
        let bestResult = { path: [], distance: Infinity, start: null, end: null };

        for (let s of startCandidates) {
          for (let t of endCandidates) {
            // If the graph does not contain the candidate (defensive)
            if (!adjacencyList[s] || !adjacencyList[t]) continue;
            const result = dijkstra(adjacencyList, s, t);
            if (result.path.length > 0 && result.distance < bestResult.distance) {
              bestResult = { path: result.path, distance: result.distance, start: s, end: t };
            }
          }
        }

        if (bestResult.path.length === 0) {
          showMessage("error", "No path found between these locations");
          currentPath = [];
          draw();
          return;
        }

        // Success - store chosen variant path
        currentPath = bestResult.path;
        currentPathDistance = bestResult.distance;
        showMessage(
          "success",
          `✅ Path found! Distance: ${bestResult.distance.toFixed(2)} units`
        );
        showDirections();
        draw();
}

      // ==================== SHOW DIRECTIONS ====================
      function showDirections() {
        const directionsSection = document.getElementById("directionsSection");
        const directionsList = document.getElementById("directionsList");
        const totalDistanceDiv = document.getElementById("totalDistance");

        directionsSection.style.display = "block";
        totalDistanceDiv.textContent = `Total Distance: ${currentPathDistance.toFixed(
          2
        )} units`;

        directionsList.innerHTML = "";

        for (let i = 0; i < currentPath.length; i++) {
          const nodeId = currentPath[i];
          const node = graphData.nodes.find((n) => n.id === nodeId);

          let stepText = "";
          let distance = 0;

          if (i === 0) {
            stepText = `Start at <strong>${nodeId}</strong>`;
          } else if (i === currentPath.length - 1) {
            stepText = `Arrive at <strong>${nodeId}</strong>`;
            // Get distance from previous node
            const prevNode = currentPath[i - 1];
            distance = adjacencyList[prevNode][nodeId];
          } else {
            stepText = `Continue to <strong>${nodeId}</strong>`;
            const prevNode = currentPath[i - 1];
            distance = adjacencyList[prevNode][nodeId];
          }

          if (node && node.type) {
            stepText += ` <span style="color: #888;">(${node.type})</span>`;
          }

          const stepDiv = document.createElement("div");
          stepDiv.className = "direction-step";
          stepDiv.innerHTML = `
                    <div class="step-number">${i + 1}</div>
                    <div class="step-text">${stepText}</div>
                    ${
                      distance > 0
                        ? `<div class="step-distance">${distance.toFixed(
                            1
                          )}u</div>`
                        : ""
                    }
                `;
          directionsList.appendChild(stepDiv);
        }
      }

      // ==================== CLEAR PATH ====================
      function clearPath() {
        currentPath = [];
        currentPathDistance = 0;
        document.getElementById("directionsSection").style.display = "none";
        document.getElementById("startNode").value = "";
        document.getElementById("endNode").value = "";
        hideMessage();
        draw();
      }

      // ==================== MESSAGES ====================
      function showMessage(type, text) {
        hideMessage();
        const messageDiv = document.getElementById(type + "Message");
        messageDiv.textContent = text;
        messageDiv.style.display = "block";

        if (type === "success") {
          setTimeout(hideMessage, 5000);
        }
      }

      function hideMessage() {
        document.getElementById("errorMessage").style.display = "none";
        document.getElementById("successMessage").style.display = "none";
      }

      // ==================== DRAWING ====================
      function draw() {
        if (!backgroundImage) return;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

        // Draw background image
        ctx.drawImage(backgroundImage, 0, 0);

        // Draw all edges (light gray)
        ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
        ctx.lineWidth = 2 / scale;
        graphData.edges.forEach((edge) => {
          const sourceNode = graphData.nodes.find((n) => n.id === edge.source);
          const targetNode = graphData.nodes.find((n) => n.id === edge.target);
          if (sourceNode && targetNode && sourceNode.x && targetNode.x) {
            ctx.beginPath();
            ctx.moveTo(sourceNode.x, sourceNode.y);
            ctx.lineTo(targetNode.x, targetNode.y);
            ctx.stroke();
          }
        });

        // Draw path if exists
        if (currentPath.length > 1) {
          ctx.strokeStyle = "#2196F3";
          ctx.lineWidth = 6 / scale;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          for (let i = 0; i < currentPath.length; i++) {
            const node = graphData.nodes.find((n) => n.id === currentPath[i]);
            if (node && node.x) {
              if (i === 0) {
                ctx.moveTo(node.x, node.y);
              } else {
                ctx.lineTo(node.x, node.y);
              }
            }
          }
          ctx.stroke();
        }

        // Draw only start and end nodes (not intermediate waypoints)
        graphData.nodes.forEach((node) => {
          if (!node.x) return;

          // Only draw if this node is the start or end of current path
          const isStart = currentPath.length > 0 && node.id === currentPath[0];
          const isEnd =
            currentPath.length > 0 &&
            node.id === currentPath[currentPath.length - 1];

          if (isStart || isEnd) {
            let color = isStart ? "#4CAF50" : "#f44336"; // Start - green, End - red
            let size = 15 / scale;

            ctx.fillStyle = color;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3 / scale;

            ctx.beginPath();
            ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw labels for start and end nodes
            ctx.fillStyle = "#000";
            ctx.font = `bold ${16 / scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(node.id, node.x, node.y - 20 / scale);
          }
        });
      }

      // ==================== ZOOM & PAN ====================
      function setupCanvasControls() {
        // Mouse events
        canvas.addEventListener("mousedown", (e) => {
          isPanning = true;
          hasPanned = false;
          const rect = canvas.getBoundingClientRect();
          startPanX = e.clientX - offsetX;
          startPanY = e.clientY - offsetY;
          canvas.style.cursor = "grabbing";
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isPanning) {
            hasPanned = true;
            offsetX = e.clientX - startPanX;
            offsetY = e.clientY - startPanY;
            draw();
          }
        });

        canvas.addEventListener("mouseup", () => {
          isPanning = false;
          canvas.style.cursor = "default";
        });

        canvas.addEventListener("mouseleave", () => {
          isPanning = false;
          canvas.style.cursor = "default";
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldX = (mouseX - offsetX) / scale;
          const worldY = (mouseY - offsetY) / scale;

          const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
          scale *= zoomFactor;
          scale = Math.max(0.1, Math.min(5, scale));

          offsetX = mouseX - worldX * scale;
          offsetY = mouseY - worldY * scale;

          draw();
        });

        // Touch events for mobile
        let lastTouchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            // Single touch - pan
            isPanning = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            startPanX = touch.clientX - offsetX;
            startPanY = touch.clientY - offsetY;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
          } else if (e.touches.length === 2) {
            // Two fingers - pinch zoom
            isPanning = false;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            lastTouchDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
          }
        });

        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && isPanning) {
            // Pan
            const touch = e.touches[0];
            offsetX = touch.clientX - startPanX;
            offsetY = touch.clientY - startPanY;
            draw();
          } else if (e.touches.length === 2) {
            // Pinch zoom
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );

            if (lastTouchDistance > 0) {
              const rect = canvas.getBoundingClientRect();
              const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
              const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;

              const worldX = (centerX - offsetX) / scale;
              const worldY = (centerY - offsetY) / scale;

              const zoomFactor = currentDistance / lastTouchDistance;
              scale *= zoomFactor;
              scale = Math.max(0.1, Math.min(5, scale));

              offsetX = centerX - worldX * scale;
              offsetY = centerY - worldY * scale;

              draw();
            }

            lastTouchDistance = currentDistance;
          }
        });

        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          isPanning = false;
          if (e.touches.length < 2) {
            lastTouchDistance = 0;
          }
        });
      }

      function zoomIn() {
        scale *= 1.2;
        scale = Math.min(5, scale);
        draw();
      }

      function zoomOut() {
        scale *= 0.8;
        scale = Math.max(0.1, scale);
        draw();
      }

      function zoomReset() {
        scale = 1;
        offsetX = 0;
        offsetY = 0;
        draw();
      }
      
      // ==================== COMPASS FUNCTIONALITY ====================
      let compassSupported = false;
      let currentHeading = 0;
      let compassCalibrated = false;
      let lastHeading = 0;
      let rotationOffset = 0;

      // Initialize compass on page load
      window.addEventListener("load", initCompass);

      function initCompass() {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");
        const compassBtn = document.getElementById("compassBtn");

        // Check if Device Orientation API is supported
        if (window.DeviceOrientationEvent) {
          // For iOS 13+ we need to request permission
          if (
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            compassLabel.textContent = "Tap to enable";
            compassLabel.style.color = "#888";
            compassBtn.style.display = "block"; // Show the button
          } else {
            // Android or older iOS - start automatically
            startCompass();
          }
        } else {
          compassLabel.textContent = "Not supported";
          compassLabel.classList.add("compass-error");
          console.warn("Device Orientation API not supported");
        }
      }

      function enableCompass() {
        const compassBtn = document.getElementById("compassBtn");
        const compassLabel = document.getElementById("compassLabel");

        // Check if permission is needed (iOS 13+)
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          compassBtn.disabled = true;
          compassBtn.textContent = "🧭 Requesting...";

          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response === "granted") {
                compassBtn.textContent = "✅ Compass Enabled";
                setTimeout(() => {
                  compassBtn.style.display = "none";
                }, 2000);
                startCompass();
              } else {
                compassLabel.textContent = "Permission denied";
                compassLabel.classList.add("compass-error");
                compassBtn.textContent = "❌ Permission Denied";
                compassBtn.disabled = false;
              }
            })
            .catch((error) => {
              console.error("Error requesting compass permission:", error);
              compassLabel.textContent = "Permission error";
              compassLabel.classList.add("compass-error");
              compassBtn.textContent = "❌ Error";
              compassBtn.disabled = false;
            });
        } else {
          // No permission needed, just start
          startCompass();
          compassBtn.style.display = "none";
        }
      }

      function requestCompassPermission() {
        // This function is kept for backward compatibility with the small button in compass
        enableCompass();
      }

      function startCompass() {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");

        compassSupported = true;
        compassLabel.textContent = "N";
        compassLabel.style.color = "#5f6368";

        // Listen for device orientation changes
        window.addEventListener("deviceorientationabsolute", handleOrientation, true);
        window.addEventListener("deviceorientation", handleOrientation, true);

        // Fallback: if no data received after 3 seconds
        setTimeout(() => {
          if (!compassCalibrated) {
            compassLabel.textContent = "No signal";
            compassLabel.classList.add("compass-error");
          }
        }, 3000);
      }

      function handleOrientation(event) {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");

        let heading = null;

        // Get compass heading
        if (event.webkitCompassHeading !== undefined) {
          // iOS
          heading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
          // Android and other devices
          heading = 360 - event.alpha;
        }

        if (heading !== null) {
          compassCalibrated = true;
          currentHeading = heading;

          // Fix rotation wrapping issue (350° -> 0° jump)
          let delta = heading - lastHeading;
          
          // Detect wrap around
          if (delta > 180) {
            // Wrapped from 359 to 0 (going counter-clockwise)
            rotationOffset -= 360;
          } else if (delta < -180) {
            // Wrapped from 0 to 359 (going clockwise)
            rotationOffset += 360;
          }
          
          lastHeading = heading;
          
          // Apply the actual rotation with offset to prevent jumping
          const actualRotation = heading + rotationOffset;
          compassPointer.style.transform = `translate(-50%, -70%) rotate(${actualRotation}deg)`;

          // Update label with cardinal direction
          const direction = getCardinalDirection(heading);
          compassLabel.textContent = direction;
          compassLabel.classList.remove("compass-error");
          compassLabel.style.color = "#5f6368";
        }
      }

      function getCardinalDirection(degrees) {
        const directions = [
          "N",
          "NNE",
          "NE",
          "ENE",
          "E",
          "ESE",
          "SE",
          "SSE",
          "S",
          "SSW",
          "SW",
          "WSW",
          "W",
          "WNW",
          "NW",
          "NNW",
        ];
        const index = Math.round(degrees / 22.5) % 16;
        return directions[index];
      }

      // Optional: Add compass visibility toggle
      function toggleCompass() {
        const compassContainer = document.getElementById("compassContainer");
        if (compassContainer.style.display === "none") {
          compassContainer.style.display = "flex";
        } else {
          compassContainer.style.display = "none";
        }
      }
    </script>
  </body>
</html>
