<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Campus Navigator - Interactive Pathfinding</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1800px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .main-content {
        display: grid;
        grid-template-columns: 380px 1fr;
        gap: 0;
        min-height: 800px;
      }

      .sidebar {
        background: #f8f9fa;
        padding: 25px;
        border-right: 2px solid #e0e0e0;
        overflow-y: auto;
        max-height: 900px;
      }

      /* Mobile Styles */
      @media (max-width: 768px) {
        body {
          padding: 0;
        }

        .container {
          border-radius: 0;
        }

        .header h1 {
          font-size: 1.8em;
        }

        .header p {
          font-size: 0.9em;
        }

        .main-content {
          grid-template-columns: 1fr;
          min-height: auto;
        }

        .sidebar {
          border-right: none;
          border-bottom: 2px solid #e0e0e0;
          max-height: none;
          padding: 15px;
        }

        .control-section {
          padding: 15px;
          margin-bottom: 15px;
        }

        .map-container {
          min-height: 400px;
          height: 60vh;
        }

        .zoom-controls {
          top: 10px;
          right: 10px;
          gap: 8px;
        }

        .zoom-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }

        .legend {
          padding: 10px;
        }

        .legend h4 {
          font-size: 12px;
        }

        .legend-item {
          font-size: 11px;
          gap: 8px;
        }

        .direction-step {
          padding: 10px;
          gap: 8px;
        }

        .step-number {
          width: 25px;
          height: 25px;
          font-size: 12px;
        }

        .step-text {
          font-size: 13px;
        }
      }

      /* Small Mobile Styles */
      @media (max-width: 480px) {
        .header {
          padding: 20px 15px;
        }

        .header h1 {
          font-size: 1.5em;
        }

        .sidebar {
          padding: 10px;
        }

        .control-section {
          padding: 12px;
        }

        .btn {
          padding: 12px;
          font-size: 14px;
        }

        .zoom-btn {
          width: 35px;
          height: 35px;
          font-size: 16px;
        }

        .map-container {
          min-height: 300px;
          height: 50vh;
        }
      }

      .btn-compass {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .btn-compass:disabled {
        background: linear-gradient(135deg, #a8b3f0 0%, #b89ac9 100%);
      }
      /* Compass Styles - Google Maps Style */
      .compass-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .compass {
        width: 50px;
        height: 50px;
        position: relative;
        background: white;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .compass:hover {
        transform: scale(1.05);
      }

      .compass-inner {
        width: 100%;
        height: 100%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .compass-pointer {
        position: absolute;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 24px solid #4285f4;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -70%);
        transform-origin: 50% 70%;
        transition: transform 0.3s ease-out;
        filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.3));
      }

      .compass-pointer::after {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 18px solid #ea4335;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
      }

      .compass-center-dot {
        position: absolute;
        width: 8px;
        height: 8px;
        background: white;
        border: 2px solid #5f6368;
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .compass-label {
        font-size: 11px;
        font-weight: 500;
        color: #5f6368;
        background: white;
        padding: 4px 8px;
        border-radius: 12px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        white-space: nowrap;
      }

      .compass-error {
        color: #ea4335;
        font-size: 10px;
      }

      @media (max-width: 768px) {
        .compass-container {
          bottom: 80px;
          right: 10px;
        }

        .compass {
          width: 45px;
          height: 45px;
        }

        .compass-pointer {
          border-left: 7px solid transparent;
          border-right: 7px solid transparent;
          border-bottom: 20px solid #4285f4;
        }

        .compass-pointer::after {
          border-left: 5px solid transparent;
          border-right: 5px solid transparent;
          border-top: 15px solid #ea4335;
        }

        .compass-label {
          font-size: 10px;
          padding: 3px 6px;
        }
      }

      .map-container {
        position: relative;
        background: #fafafa;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .control-section {
        margin-bottom: 20px;
        padding: 20px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .control-section h3 {
        color: #667eea;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      .input-group {
        margin-bottom: 15px;
      }

      .input-group label {
        display: block;
        margin-bottom: 5px;
        color: #555;
        font-weight: 600;
        font-size: 14px;
      }

      select,
      input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 15px;
        transition: border-color 0.3s;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        width: 100%;
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        margin-top: 10px;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .directions {
        margin-top: 15px;
        max-height: 400px;
        overflow-y: auto;
      }

      .direction-step {
        padding: 12px;
        background: white;
        border-left: 4px solid #667eea;
        margin-bottom: 10px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .step-number {
        background: #667eea;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        flex-shrink: 0;
        font-size: 14px;
      }

      .step-text {
        flex: 1;
        font-size: 14px;
      }

      .step-distance {
        color: #888;
        font-size: 0.85em;
        font-weight: 600;
      }

      .total-distance {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      canvas {
        display: block;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .zoom-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 100;
      }

      .zoom-btn {
        width: 45px;
        height: 45px;
        background: white;
        border: 2px solid #667eea;
        border-radius: 8px;
        font-size: 20px;
        font-weight: bold;
        color: #667eea;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.2s;
      }

      .zoom-btn:hover {
        background: #667eea;
        color: white;
        transform: scale(1.1);
      }

      .legend {
        background: white;
        padding: 15px;
        border-radius: 8px;
      }

      .legend h4 {
        margin-bottom: 10px;
        color: #667eea;
        font-size: 14px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        font-size: 13px;
      }

      .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #333;
      }

      .legend-line {
        width: 30px;
        height: 4px;
        border-radius: 2px;
      }

      .message {
        padding: 12px;
        border-radius: 8px;
        margin-top: 10px;
        font-size: 14px;
        display: none;
      }

      .error-message {
        background: #ff4444;
        color: white;
      }

      .success-message {
        background: #00c851;
        color: white;
      }

      .info-message {
        background: #33b5e5;
        color: white;
      }

      .file-upload-section {
        background: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 2px dashed #667eea;
      }

      .file-upload-section h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .upload-btn {
        background: #667eea;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        margin: 5px 0;
        width: 100%;
      }

      .upload-btn:hover {
        background: #5568d3;
      }

      .file-name {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üó∫Ô∏è Campus Navigator</h1>
        <p>Find the shortest path between any two locations</p>
      </div>

      <div class="main-content">
        <div class="sidebar">
          <!-- File Upload Section (Optional - files auto-load) -->
          <div class="file-upload-section" id="uploadSection" style="display: none;">
            <h3>üìÅ Load Different Map (Optional)</h3>
            <label for="graphFile" class="upload-btn"
              >1. Select Graph JSON File</label
            >
            <input
              type="file"
              id="graphFile"
              accept=".json"
              style="display: none"
            />
            <div class="file-name" id="graphFileName">No file selected</div>

            <label for="imageFile" class="upload-btn" style="margin-top: 10px"
              >2. Select Floor Plan Image</label
            >
            <input
              type="file"
              id="imageFile"
              accept="image/*"
              style="display: none"
            />
            <div class="file-name" id="imageFileName">No file selected</div>
          </div>

          <!-- Route Selection -->
          <div class="control-section" id="routeSection">
            <h3>üìç Select Your Route</h3>

            <div class="input-group">
              <label for="startFloor">Starting Floor:</label>
              <select id="startFloor" onchange="updateStartNodes()">
                <option value="">-- Select Floor --</option>
                <option value="0">Plaza Floor (Ground)</option>
                <option value="1">First Floor</option>
              </select>
            </div>

            <div class="input-group">
              <label for="startNode">Starting Point:</label>
              <select id="startNode" disabled>
                <option value="">-- Select Floor First --</option>
              </select>
            </div>

            <div class="input-group">
              <label for="endFloor">Destination Floor:</label>
              <select id="endFloor" onchange="updateEndNodes()">
                <option value="">-- Select Floor --</option>
                <option value="0">Plaza Floor (Ground)</option>
                <option value="1">First Floor</option>
              </select>
            </div>

            <div class="input-group">
              <label for="endNode">Destination:</label>
              <select id="endNode" disabled>
                <option value="">-- Select Floor First --</option>
              </select>
            </div>

            <button class="btn" id="findPathBtn" onclick="findPath()">
              üöÄ Find Shortest Path
            </button>

            <button class="btn btn-secondary" onclick="clearPath()">
              üîÑ Clear Path
            </button>

            <button class="btn btn-compass" id="compassBtn" onclick="enableCompass()" style="display: none;">
              üß≠ Enable Compass
            </button>

            <div class="message error-message" id="errorMessage"></div>
            <div class="message success-message" id="successMessage"></div>
          </div>

          <!-- Directions -->
          <div
            class="control-section"
            id="directionsSection"
            style="display: none"
          >
            <h3>üìã Turn-by-Turn Directions</h3>
            <div class="total-distance" id="totalDistance"></div>
            <div class="directions" id="directionsList"></div>
          </div>

          <!-- Legend -->
          <div class="control-section">
            <div class="legend">
              <h4>Legend:</h4>
              <div class="legend-item">
                <div class="legend-color" style="background: #4caf50"></div>
                <span>Start Point</span>
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #f44336"></div>
                <span>Destination</span>
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #ff9800"></div>
                <span>Waypoint</span>
              </div>
              <div class="legend-item">
                <div class="legend-line" style="background: #2196f3"></div>
                <span>Shortest Path</span>
              </div>
            </div>
          </div>
        </div>

        <div class="map-container">
          <div class="zoom-controls" id="zoomControls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="zoomReset()">‚äô</button>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
          </div>

          <div class="rotation-controls" id="rotationControls" style="position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 100;">
            <button class="zoom-btn" onclick="rotateLeft()" title="Rotate Left">‚Ü∂</button>
            <button class="zoom-btn" onclick="resetRotation()" title="Reset Rotation">‚äï</button>
            <button class="zoom-btn" onclick="rotateRight()" title="Rotate Right">‚Ü∑</button>
          </div>

                    
          <!-- Compass -->
          <div class="compass-container" id="compassContainer">
            <div class="compass" id="compass" title="Compass">
              <div class="compass-inner">
                <!-- Blue pointer arrow pointing North -->
                <div class="compass-pointer" id="compassPointer"></div>
                
                <!-- Center dot -->
                <div class="compass-center-dot"></div>
              </div>
            </div>
            <div class="compass-label" id="compassLabel">---</div>
          </div>


          <canvas id="mapCanvas"></canvas>
          <div
            class="message info-message"
            id="infoMessage"
            style="
              position: absolute;
              display: none;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              padding: 30px;
              font-size: 16px;
            "
          >
            Loading map...
          </div>
        </div>
      </div>
    </div>

    <!-- Load graph data as JavaScript -->
    <script src="graph_data_floor0.js"></script>
    <script src="graph_data_floor1.js"></script>

    <script>
      // ==================== DIJKSTRA'S ALGORITHM ====================
      class PriorityQueue {
        constructor() {
          this.values = [];
        }

        enqueue(val, priority) {
          this.values.push({ val, priority });
          this.sort();
        }

        dequeue() {
          return this.values.shift();
        }

        sort() {
          this.values.sort((a, b) => a.priority - b.priority);
        }

        isEmpty() {
          return this.values.length === 0;
        }
      }

      function dijkstra(graph, start, end) {
        const distances = {};
        const previous = {};
        const pq = new PriorityQueue();

        // Initialize distances
        for (let node in graph) {
          distances[node] = Infinity;
          previous[node] = null;
        }
        distances[start] = 0;
        pq.enqueue(start, 0);

        while (!pq.isEmpty()) {
          const { val: currentNode } = pq.dequeue();

          if (currentNode === end) {
            // Build path
            const path = [];
            let current = end;
            while (current !== null) {
              path.unshift(current);
              current = previous[current];
            }
            return { path, distance: distances[end] };
          }

          if (graph[currentNode]) {
            for (let neighbor in graph[currentNode]) {
              const weight = graph[currentNode][neighbor];
              const newDistance = distances[currentNode] + weight;

              if (newDistance < distances[neighbor]) {
                distances[neighbor] = newDistance;
                previous[neighbor] = currentNode;
                pq.enqueue(neighbor, newDistance);
              }
            }
          }
        }

        return { path: [], distance: Infinity };
      }

      // ==================== GLOBAL VARIABLES ====================
      const canvas = document.getElementById("mapCanvas");
      const ctx = canvas.getContext("2d");

      let graphData = null;
      let adjacencyList = {};
      let backgroundImage = null;
      let currentPath = [];
      let currentPathDistance = 0;
      let baseToVariants = {};

      // Multi-floor support
      let currentFloor = 0; // Currently displayed floor (0 or 1)
      let floorGraphs = {}; // {0: FLOOR_0_DATA, 1: FLOOR_1_DATA}
      let floorImages = {}; // {0: Image, 1: Image}
      let separateAdjacencyLists = {}; // {0: adjacencyList0, 1: adjacencyList1} - SEPARATE for each floor
      let fullPath = []; // Complete path including floor transitions
      let floorTransitions = []; // Array of {nodeId, fromFloor, toFloor}

      // Zoom and pan
      let scale = 1;
      let minScale = 1; // Minimum scale to fit image in canvas
      let offsetX = 0;
      let offsetY = 0;
      let isPanning = false;
      let hasPanned = false;
      let startPanX = 0;
      let startPanY = 0;
      let rotation = 0; // Map rotation in degrees

      // Node colors by type
      const nodeColors = {
        entrance: "#FF6B6B",
        hallway: "#4ECDC4",
        room: "#95E1D3",
        elevator: "#FFD93D",
        stairs: "#FFA07A",
        restroom: "#DDA0DD",
        outdoor: "#90EE90",
        building: "#FFB6C1",
        classroom: "#87CEEB",
      };

      // ==================== AUTO-LOAD FILES ON PAGE LOAD ====================
      window.addEventListener('load', async () => {
        try {
          // Load both floor graph data
          floorGraphs[0] = FLOOR_0_DATA;
          floorGraphs[1] = FLOOR_1_DATA;
          
          console.log('‚úÖ Floor graph data loaded');

          // Load Floor 0 image (Plaza Floor)
          const img0 = new Image();
          img0.onload = () => {
            floorImages[0] = img0;
            console.log('‚úÖ Plaza floor image loaded');
            checkBothFloorsLoaded();
          };
          img0.onerror = () => {
            alert('Error loading plaza floor.jpg. Make sure the file exists in the same directory.');
          };
          img0.src = 'plaza floor.jpg';

          // Load Floor 1 image (First Floor)
          const img1 = new Image();
          img1.onload = () => {
            floorImages[1] = img1;
            console.log('‚úÖ First floor image loaded');
            checkBothFloorsLoaded();
          };
          img1.onerror = () => {
            alert('Error loading first floor.jpg. Make sure the file exists in the same directory.');
          };
          img1.src = 'first floor.jpg';

        } catch (error) {
          console.error('Error loading files:', error);
          alert('Error loading map. Make sure graph_data_floor0.js and graph_data_floor1.js are in the same directory.');
        }
      });

      function checkBothFloorsLoaded() {
        if (floorImages[0] && floorImages[1]) {
          // Set initial floor to 0
          currentFloor = 0;
          backgroundImage = floorImages[0];
          graphData = floorGraphs[0];

          // Set canvas to fill the container
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Calculate initial scale to fit image in canvas
          const scaleX = canvas.width / backgroundImage.width;
          const scaleY = canvas.height / backgroundImage.height;
          minScale = Math.min(scaleX, scaleY);
          scale = minScale;
          
          // Center the image
          offsetX = (canvas.width - backgroundImage.width * scale) / 2;
          offsetY = (canvas.height - backgroundImage.height * scale) / 2;

          // Build separate graphs and populate dropdowns
          buildSeparateGraphs();
          setupCanvasControls();
          addFloorSwitcher();
          draw();
          console.log('‚úÖ Multi-floor map ready');
          checkIfReady();
        }
      }

      // ==================== OPTIONAL FILE UPLOAD HANDLERS ====================
      document
        .getElementById("graphFile")
        .addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (file) {
            const text = await file.text();
            graphData = JSON.parse(text);
            buildAdjacencyList();
            populateDropdowns();
            document.getElementById(
              "graphFileName"
            ).textContent = `‚úÖ ${file.name}`;
            checkIfReady();
          }
        });

      document.getElementById("imageFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              backgroundImage = img;
              
              // Set canvas to fill the container
              const container = canvas.parentElement;
              canvas.width = container.clientWidth;
              canvas.height = container.clientHeight;
              
              // Calculate initial scale to fit image in canvas
              const scaleX = canvas.width / img.width;
              const scaleY = canvas.height / img.height;
              minScale = Math.min(scaleX, scaleY);
              scale = minScale;
              
              // Center the image
              offsetX = (canvas.width - img.width * scale) / 2;
              offsetY = (canvas.height - img.height * scale) / 2;
              
              document.getElementById(
                "imageFileName"
              ).textContent = `‚úÖ ${file.name}`;
              checkIfReady();
              setupCanvasControls();
              draw();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      function checkIfReady() {
        if (graphData && backgroundImage) {
          document.getElementById("uploadSection").style.display = "none";
          document.getElementById("routeSection").style.display = "block";
          document.getElementById("zoomControls").style.display = "flex";
          document.getElementById("infoMessage").style.display = "none";
        }
      }

      // ==================== BUILD ADJACENCY LIST ====================
      function buildSeparateGraphs() {
        separateAdjacencyLists = {};

        // Build SEPARATE adjacency list for each floor (NO inter-floor connections)
        Object.keys(floorGraphs).forEach(floor => {
          const graph = floorGraphs[floor];
          const adjList = {};
          
          // Initialize all nodes
          graph.nodes.forEach((node) => {
            adjList[node.id] = {};
          });

          // Add edges - ONLY if both nodes are on SAME floor
          graph.edges.forEach((edge) => {
            // Skip inter-floor edges (they have type: "inter-floor")
            if (edge.type === "inter-floor") return;
            
            if (!adjList[edge.source]) adjList[edge.source] = {};
            if (!adjList[edge.target]) adjList[edge.target] = {};
            
            adjList[edge.source][edge.target] = edge.weight;
            adjList[edge.target][edge.source] = edge.weight;
          });
          
          separateAdjacencyLists[floor] = adjList;
          console.log(`‚úÖ Floor ${floor} graph built with`, Object.keys(adjList).length, 'nodes');
        });
      }

      function buildAdjacencyList() {
        // Legacy function - now using buildSeparateGraphs
        buildSeparateGraphs();
      }

      // ==================== POPULATE DROPDOWNS ====================
      
      function updateStartNodes() {
        const startFloor = document.getElementById("startFloor").value;
        const startSelect = document.getElementById("startNode");
        
        if (!startFloor) {
          startSelect.disabled = true;
          startSelect.innerHTML = '<option value="">-- Select Floor First --</option>';
          return;
        }
        
        startSelect.disabled = false;
        startSelect.innerHTML = '<option value="">-- Select Start --</option>';
        
        const floor = parseInt(startFloor);
        const graph = floorGraphs[floor];
        
        // Build base -> variants map for this floor only
        const baseToVariants = {};
        graph.nodes.forEach((node) => {
          const id = node.id;
          const lastChar = id.slice(-1);
          let baseId = id;
          if (/^[abc]$/i.test(lastChar) && /^[A-Za-z0-9]+[abcABC]$/.test(id)) {
            baseId = id.slice(0, -1);
          }
          
          if (!baseToVariants[baseId]) baseToVariants[baseId] = [];
          baseToVariants[baseId].push(id);
        });
        
        // Sort and add to dropdown
        const sortedBases = Object.keys(baseToVariants).sort((a, b) => a.localeCompare(b));
        
        sortedBases.forEach((baseId) => {
          // Skip hallways
          if (baseId.startsWith("H")) return;
          
          const option = document.createElement("option");
          option.value = baseId;
          option.textContent = baseId;
          startSelect.appendChild(option);
        });
      }
      
      function updateEndNodes() {
        const endFloor = document.getElementById("endFloor").value;
        const endSelect = document.getElementById("endNode");
        
        if (!endFloor) {
          endSelect.disabled = true;
          endSelect.innerHTML = '<option value="">-- Select Floor First --</option>';
          return;
        }
        
        endSelect.disabled = false;
        endSelect.innerHTML = '<option value="">-- Select Destination --</option>';
        
        const floor = parseInt(endFloor);
        const graph = floorGraphs[floor];
        
        // Build base -> variants map for this floor only
        const baseToVariants = {};
        graph.nodes.forEach((node) => {
          const id = node.id;
          const lastChar = id.slice(-1);
          let baseId = id;
          if (/^[abc]$/i.test(lastChar) && /^[A-Za-z0-9]+[abcABC]$/.test(id)) {
            baseId = id.slice(0, -1);
          }
          
          if (!baseToVariants[baseId]) baseToVariants[baseId] = [];
          baseToVariants[baseId].push(id);
        });
        
        // Sort and add to dropdown
        const sortedBases = Object.keys(baseToVariants).sort((a, b) => a.localeCompare(b));
        
        sortedBases.forEach((baseId) => {
          // Skip hallways
          if (baseId.startsWith("H")) return;
          
          const option = document.createElement("option");
          option.value = baseId;
          option.textContent = baseId;
          endSelect.appendChild(option);
        });
      }
      
      function populateDropdowns() {
        // Legacy - now using updateStartNodes and updateEndNodes
      }

      // ==================== FIND PATH ====================
     
      function findPath() {
        const startFloorNum = parseInt(document.getElementById("startFloor").value);
        const endFloorNum = parseInt(document.getElementById("endFloor").value);
        const startNode = document.getElementById("startNode").value;
        const endNode = document.getElementById("endNode").value;

        // Validation
        if (isNaN(startFloorNum) || isNaN(endFloorNum)) {
          showMessage("error", "Please select both start and destination floors");
          return;
        }
        
        if (!startNode || !endNode) {
          showMessage("error", "Please select both start and destination points");
          return;
        }

        if (startFloorNum === endFloorNum && startNode === endNode) {
          showMessage("error", "Start and destination cannot be the same");
          return;
        }

        // Get actual node IDs (resolve variants)
        const startGraph = floorGraphs[startFloorNum];
        const endGraph = floorGraphs[endFloorNum];
        
        const startCandidates = getNodeVariants(startNode, startGraph);
        const endCandidates = getNodeVariants(endNode, endGraph);

        if (startCandidates.length === 0 || endCandidates.length === 0) {
          showMessage("error", "Invalid node selection");
          return;
        }

        // CASE 1: Same floor navigation - simple pathfinding
        if (startFloorNum === endFloorNum) {
          findSameFloorPath(startFloorNum, startCandidates, endCandidates);
        } 
        // CASE 2: Cross-floor navigation - must use stairs/elevators
        else {
          findCrossFloorPath(startFloorNum, endFloorNum, startCandidates, endCandidates);
        }
      }

      // Helper to get all variant node IDs for a base ID
      function getNodeVariants(baseId, graph) {
        const variants = [];
        graph.nodes.forEach(node => {
          const id = node.id;
          const lastChar = id.slice(-1);
          let nodeBase = id;
          if (/^[abc]$/i.test(lastChar) && /^[A-Za-z0-9]+[abcABC]$/.test(id)) {
            nodeBase = id.slice(0, -1);
          }
          if (nodeBase === baseId) {
            variants.push(id);
          }
        });
        return variants;
      }

      // Find path on same floor
      function findSameFloorPath(floor, startCandidates, endCandidates) {
        const adjList = separateAdjacencyLists[floor];
        let bestResult = { path: [], distance: Infinity };

        for (let s of startCandidates) {
          for (let e of endCandidates) {
            if (!adjList[s] || !adjList[e]) continue;
            const result = dijkstra(adjList, s, e);
            if (result.path.length > 0 && result.distance < bestResult.distance) {
              bestResult = result;
            }
          }
        }

        if (bestResult.path.length === 0) {
          showMessage("error", "No path found between these locations");
          currentPath = [];
          fullPath = [];
          floorTransitions = [];
          draw();
          return;
        }

        // Set current floor and display path
        switchToFloor(floor);
        currentPath = bestResult.path;
        fullPath = bestResult.path;
        floorTransitions = [];
        currentPathDistance = bestResult.distance;
        
        showMessage("success", `‚úÖ Path found! Distance: ${bestResult.distance.toFixed(2)} units`);
        showDirections();
        zoomToStartingPoint();
        draw();
      }

      // Find path across floors using stairs/elevators
      function findCrossFloorPath(startFloor, endFloor, startCandidates, endCandidates) {
        // Get all stairs and elevators on each floor
        const startFloorTransitions = getTransitionNodes(startFloor);
        const endFloorTransitions = getTransitionNodes(endFloor);
        
        if (startFloorTransitions.length === 0 || endFloorTransitions.length === 0) {
          showMessage("error", "No stairs or elevators found to connect floors");
          currentPath = [];
          fullPath = [];
          floorTransitions = [];
          draw();
          return;
        }

        // Find best path: start -> transition on floor1 -> transition on floor2 -> end
        let bestTotalPath = [];
        let bestTotalDistance = Infinity;
        let bestTransition = null;

        for (let startId of startCandidates) {
          for (let endId of endCandidates) {
            for (let trans1 of startFloorTransitions) {
              for (let trans2 of endFloorTransitions) {
                // Check if these transitions are connected (same base ID)
                if (!areTransitionsConnected(trans1, trans2)) continue;

                // Path segment 1: start -> transition on start floor
                const adjList1 = separateAdjacencyLists[startFloor];
                const seg1 = dijkstra(adjList1, startId, trans1.id);
                if (seg1.path.length === 0) continue;

                // Path segment 2: transition on end floor -> end
                const adjList2 = separateAdjacencyLists[endFloor];
                const seg2 = dijkstra(adjList2, trans2.id, endId);
                if (seg2.path.length === 0) continue;

                // Calculate total distance (including transition weight)
                const transitionWeight = trans1.type === 'elevator' ? 15 : 30;
                const totalDistance = seg1.distance + transitionWeight + seg2.distance;

                if (totalDistance < bestTotalDistance) {
                  bestTotalDistance = totalDistance;
                  bestTotalPath = [...seg1.path, ...seg2.path.slice(1)]; // Avoid duplicate transition node
                  bestTransition = { node: trans1.id, fromFloor: startFloor, toFloor: endFloor };
                }
              }
            }
          }
        }

        if (bestTotalPath.length === 0) {
          showMessage("error", "No path found between floors");
          currentPath = [];
          fullPath = [];
          floorTransitions = [];
          draw();
          return;
        }

        // Store the full path and transition point
        fullPath = bestTotalPath;
        currentPathDistance = bestTotalDistance;
        floorTransitions = [bestTransition];
        
        // Show path on starting floor
        switchToFloor(startFloor);
        updateCurrentPathForFloor(startFloor);
        
        showMessage("success", `‚úÖ Path found! Distance: ${bestTotalDistance.toFixed(2)} units (crosses floors)`);
        showDirections();
        zoomToStartingPoint();
        draw();
      }

      // Get all transition nodes (stairs/elevators) on a floor
      function getTransitionNodes(floor) {
        const graph = floorGraphs[floor];
        const transitions = [];
        
        graph.nodes.forEach(node => {
          if (node.type === 'stairs' || node.type === 'elevator') {
            transitions.push(node);
          }
        });
        
        return transitions;
      }

      // Check if two transition nodes are connected (same base ID)
      function areTransitionsConnected(trans1, trans2) {
        // They should have the same base ID (e.g., ST01, ET01)
        return trans1.id === trans2.id;
      }

      // Update current path to show only nodes on specified floor
      function updateCurrentPathForFloor(floor) {
        if (floorTransitions.length === 0) {
          // Same floor path
          currentPath = fullPath;
          return;
        }
        
        // Cross-floor path - show segment for current floor
        const transition = floorTransitions[0];
        const transitionNodeId = transition.node;
        const transitionIndex = fullPath.indexOf(transitionNodeId);
        
        if (floor === transition.fromFloor) {
          // Show start to transition
          currentPath = fullPath.slice(0, transitionIndex + 1);
        } else if (floor === transition.toFloor) {
          // Show transition to end
          currentPath = fullPath.slice(transitionIndex);
        } else {
          currentPath = [];
        }
      }

      // ==================== SHOW DIRECTIONS ====================
      function showDirections() {
        // User doesn't want to see directions list - keeping function minimal
        // Just hide the directions section
        const directionsSection = document.getElementById("directionsSection");
        directionsSection.style.display = "none";
      }

      // ==================== CLEAR PATH ====================
      function clearPath() {
        currentPath = [];
        fullPath = [];
        floorTransitions = [];
        currentPathDistance = 0;
        document.getElementById("directionsSection").style.display = "none";
        document.getElementById("startFloor").value = "";
        document.getElementById("endFloor").value = "";
        document.getElementById("startNode").value = "";
        document.getElementById("startNode").disabled = true;
        document.getElementById("startNode").innerHTML = '<option value="">-- Select Floor First --</option>';
        document.getElementById("endNode").value = "";
        document.getElementById("endNode").disabled = true;
        document.getElementById("endNode").innerHTML = '<option value="">-- Select Floor First --</option>';
        hideMessage();
        draw();
      }

      // ==================== FLOOR SWITCHING ====================
      function addFloorSwitcher() {
        const container = document.querySelector('.map-container');
        
        const floorSwitcher = document.createElement('div');
        floorSwitcher.id = 'floorSwitcher';
        floorSwitcher.style.cssText = `
          position: absolute;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          display: flex;
          gap: 10px;
          z-index: 100;
          background: white;
          padding: 10px;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        
        // Floor 0 button
        const btn0 = document.createElement('button');
        btn0.textContent = 'Plaza Floor';
        btn0.className = 'zoom-btn floor-btn';
        btn0.style.width = 'auto';
        btn0.style.padding = '10px 20px';
        btn0.style.background = '#667eea';
        btn0.style.color = 'white';
        btn0.onclick = () => switchToFloor(0);
        
        // Floor 1 button
        const btn1 = document.createElement('button');
        btn1.textContent = 'First Floor';
        btn1.className = 'zoom-btn floor-btn';
        btn1.style.width = 'auto';
        btn1.style.padding = '10px 20px';
        btn1.onclick = () => switchToFloor(1);
        
        floorSwitcher.appendChild(btn0);
        floorSwitcher.appendChild(btn1);
        
        container.appendChild(floorSwitcher);
        
        // Add mobile-specific styling
        const style = document.createElement('style');
        style.textContent = `
          @media (max-width: 768px) {
            #floorSwitcher {
              bottom: 10px !important;
              padding: 6px !important;
              gap: 6px !important;
            }
            #floorSwitcher .floor-btn {
              padding: 6px 12px !important;
              font-size: 12px !important;
              min-width: 70px !important;
              height: 32px !important;
            }
          }
        `;
        document.head.appendChild(style);
      }

      function switchToFloor(floor) {
        if (!floorImages[floor]) {
          alert(`Floor ${floor} image not loaded yet`);
          return;
        }
        
        currentFloor = floor;
        backgroundImage = floorImages[floor];
        graphData = floorGraphs[floor];
        
        // Update floor switcher buttons
        const buttons = document.querySelectorAll('#floorSwitcher button');
        buttons.forEach((btn, index) => {
          if (index === floor) {
            btn.style.background = '#667eea';
            btn.style.color = 'white';
          } else {
            btn.style.background = 'white';
            btn.style.color = '#667eea';
          }
        });
        
        // Update current path for this floor
        if (fullPath.length > 0) {
          updateCurrentPathForFloor(floor);
        }
        
        // Recalculate scale for new image
        const scaleX = canvas.width / backgroundImage.width;
        const scaleY = canvas.height / backgroundImage.height;
        minScale = Math.min(scaleX, scaleY);
        
        // Auto-zoom to starting point of path on this floor
        if (currentPath.length > 0) {
          const startNodeId = currentPath[0];
          const startNode = graphData.nodes.find((n) => n.id === startNodeId);
          
          if (startNode && startNode.x) {
            // Set zoom level to 1.8x for good detail
            scale = 1.8;
            
            // Center the view on the starting point of this floor's path
            offsetX = canvas.width / 2 - startNode.x * scale;
            offsetY = canvas.height / 2 - startNode.y * scale;
            
            // Constrain to keep within image boundaries
            constrainPan();
          }
        } else {
          // No path - reset to default view
          scale = minScale;
          offsetX = (canvas.width - backgroundImage.width * scale) / 2;
          offsetY = (canvas.height - backgroundImage.height * scale) / 2;
        }
        
        draw();
      }

      // ==================== ZOOM TO STARTING POINT ====================
      function zoomToStartingPoint() {
        if (currentPath.length === 0) return;
        
        // Get the starting node
        const startNodeId = currentPath[0];
        const startNode = graphData.nodes.find((n) => n.id === startNodeId);
        
        if (!startNode || !startNode.x) return;
        
        // Set zoom level to 2.5x for good detail
        scale = 1.8;
        
        // Center the view on the starting point
        // Calculate offsets to center the start node in the canvas
        offsetX = canvas.width / 2 - startNode.x * scale;
        offsetY = canvas.height / 2 - startNode.y * scale;
        
        // Constrain to keep within image boundaries
        constrainPan();
      }

      // ==================== MESSAGES ====================
      function showMessage(type, text) {
        hideMessage();
        const messageDiv = document.getElementById(type + "Message");
        messageDiv.textContent = text;
        messageDiv.style.display = "block";

        if (type === "success") {
          setTimeout(hideMessage, 5000);
        }
      }

      function hideMessage() {
        document.getElementById("errorMessage").style.display = "none";
        document.getElementById("successMessage").style.display = "none";
      }

      // ==================== DRAWING ====================
      function draw() {
        if (!backgroundImage) return;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply transformations: translate to center, rotate, then scale and offset
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rotation * Math.PI / 180);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
        
        // Apply rotation around the center of the canvas
        const centerX = canvas.width / (2 * scale) - offsetX / scale;
        const centerY = canvas.height / (2 * scale) - offsetY / scale;
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation * Math.PI / 180);
        ctx.translate(-centerX, -centerY);

        // Draw background image
        ctx.drawImage(backgroundImage, 0, 0);

        // Draw all edges - INVISIBLE (edges hidden per user request)
        // Edges are not drawn so only the blue path appears
        
        // Draw path if exists
        if (currentPath.length > 1) {
          ctx.strokeStyle = "#2196F3";
          ctx.lineWidth = 6 / scale;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          for (let i = 0; i < currentPath.length; i++) {
            const node = graphData.nodes.find((n) => n.id === currentPath[i]);
            if (node && node.x) {
              if (i === 0) {
                ctx.moveTo(node.x, node.y);
              } else {
                ctx.lineTo(node.x, node.y);
              }
            }
          }
          ctx.stroke();

          // Draw directional arrows along the path
          ctx.fillStyle = "#2196F3";
          const arrowSize = 12 / scale;
          
          for (let i = 0; i < currentPath.length - 1; i++) {
            // Only draw arrow on every other segment to reduce quantity
            if (i % 2 !== 0) continue;
            
            const currentNode = graphData.nodes.find((n) => n.id === currentPath[i]);
            const nextNode = graphData.nodes.find((n) => n.id === currentPath[i + 1]);
            
            if (currentNode && nextNode && currentNode.x && nextNode.x) {
              // Calculate midpoint between current and next node
              const midX = (currentNode.x + nextNode.x) / 2;
              const midY = (currentNode.y + nextNode.y) / 2;
              
              // Calculate angle from current to next node
              const angle = Math.atan2(nextNode.y - currentNode.y, nextNode.x - currentNode.x);
              
              // Draw arrow at midpoint
              ctx.save();
              ctx.translate(midX, midY);
              ctx.rotate(angle);
              
              // Draw arrowhead pointing right (will be rotated to correct direction)
              ctx.beginPath();
              ctx.moveTo(arrowSize, 0);
              ctx.lineTo(-arrowSize / 2, -arrowSize);
              ctx.lineTo(-arrowSize / 2, arrowSize);
              ctx.closePath();
              ctx.fill();
              
              ctx.restore();
            }
          }
        }

        // Draw only start and end nodes (not intermediate waypoints)
        graphData.nodes.forEach((node) => {
          if (!node.x) return;

          // Only draw if this node is the start or end of current path
          const isStart = currentPath.length > 0 && node.id === currentPath[0];
          const isEnd =
            currentPath.length > 0 &&
            node.id === currentPath[currentPath.length - 1];

          if (isStart || isEnd) {
            let color = isStart ? "#4CAF50" : "#f44336"; // Start - green, End - red
            let size = 15 / scale;

            ctx.fillStyle = color;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3 / scale;

            ctx.beginPath();
            ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw labels for start and end nodes
            ctx.fillStyle = "#000";
            ctx.font = `bold ${16 / scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(node.id, node.x, node.y - 20 / scale);
          }
        });

        // Draw floor transition indicators
        // Only show at the LAST node in current path if there's a transition to another floor
        if (fullPath.length > 0 && floorTransitions.length > 0) {
          const transition = floorTransitions[0];
          
          // Only draw if we're on the floor that has the transition point
          if (currentFloor === transition.fromFloor && currentPath.length > 0) {
            const lastNodeId = currentPath[currentPath.length - 1];
            
            // Only show transition button if last node IS the transition point
            if (lastNodeId === transition.node) {
              const node = graphData.nodes.find(n => n.id === lastNodeId);
              if (node && node.x) {
                // Draw transition icon (up/down arrow)
                const isGoingUp = transition.toFloor > transition.fromFloor;
                const arrowText = isGoingUp ? '‚ñ≤' : '‚ñº';
                const buttonColor = isGoingUp ? '#4CAF50' : '#FF9800';
                
                // Draw circle button
                ctx.fillStyle = buttonColor;
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3 / scale;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20 / scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw arrow
                ctx.fillStyle = "#FFF";
                ctx.font = `bold ${24 / scale}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(arrowText, node.x, node.y);
                
                // Draw label
                ctx.fillStyle = "#000";
                ctx.font = `bold ${14 / scale}px Arial`;
                ctx.textBaseline = "top";
                const floorName = transition.toFloor === 0 ? 'Plaza' : `Floor ${transition.toFloor}`;
                ctx.fillText(`Go to ${floorName}`, node.x, node.y + 25 / scale);
              }
            }
          }
        }
      }

      // ==================== ZOOM & PAN ====================
      // Helper function to check if click is on floor transition button
      function checkFloorTransitionClick(e) {
        if (floorTransitions.length === 0 || currentPath.length === 0) return;
        
        const transition = floorTransitions[0];
        
        // Only check if we're on the from-floor
        if (currentFloor !== transition.fromFloor) return;
        
        const lastNodeId = currentPath[currentPath.length - 1];
        
        // Only check if last node is the transition point
        if (lastNodeId !== transition.node) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert to world coordinates
        const worldX = (mouseX - offsetX) / scale;
        const worldY = (mouseY - offsetY) / scale;
        
        // Get the transition node position
        const node = graphData.nodes.find(n => n.id === lastNodeId);
        if (node && node.x) {
          const distance = Math.sqrt(
            Math.pow(worldX - node.x, 2) + Math.pow(worldY - node.y, 2)
          );
          
          // Click radius (20 units in world coordinates)
          if (distance < 20 / scale * 50) {
            // Clicked on transition button!
            switchToFloor(transition.toFloor);
          }
        }
      }

      // Helper function to constrain panning within image boundaries
      function constrainPan() {
        const scaledWidth = backgroundImage.width * scale;
        const scaledHeight = backgroundImage.height * scale;

        // Don't allow panning beyond image boundaries
        // Left boundary
        if (offsetX > 0) offsetX = 0;
        // Right boundary
        if (offsetX < canvas.width - scaledWidth) offsetX = canvas.width - scaledWidth;
        // Top boundary
        if (offsetY > 0) offsetY = 0;
        // Bottom boundary
        if (offsetY < canvas.height - scaledHeight) offsetY = canvas.height - scaledHeight;

        // If image is smaller than canvas, center it
        if (scaledWidth < canvas.width) {
          offsetX = (canvas.width - scaledWidth) / 2;
        }
        if (scaledHeight < canvas.height) {
          offsetY = (canvas.height - scaledHeight) / 2;
        }
      }

      function setupCanvasControls() {
        // Mouse events
        canvas.addEventListener("mousedown", (e) => {
          isPanning = true;
          hasPanned = false;
          const rect = canvas.getBoundingClientRect();
          startPanX = e.clientX;
          startPanY = e.clientY;
          canvas.style.cursor = "grabbing";
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isPanning) {
            hasPanned = true;
            
            // Calculate the movement delta
            const deltaX = e.clientX - startPanX;
            const deltaY = e.clientY - startPanY;
            
            // Rotate the delta based on current rotation
            const rotRad = -rotation * Math.PI / 180;
            const rotatedDeltaX = deltaX * Math.cos(rotRad) - deltaY * Math.sin(rotRad);
            const rotatedDeltaY = deltaX * Math.sin(rotRad) + deltaY * Math.cos(rotRad);
            
            // Apply the rotated delta
            offsetX += rotatedDeltaX;
            offsetY += rotatedDeltaY;
            
            // Update start position for next movement
            startPanX = e.clientX;
            startPanY = e.clientY;
            
            constrainPan();
            draw();
          }
        });

        canvas.addEventListener("mouseup", (e) => {
          if (!hasPanned) {
            // Click detected - check if clicked on floor transition button
            checkFloorTransitionClick(e);
          }
          isPanning = false;
          canvas.style.cursor = "default";
        });

        canvas.addEventListener("mouseleave", () => {
          isPanning = false;
          canvas.style.cursor = "default";
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldX = (mouseX - offsetX) / scale;
          const worldY = (mouseY - offsetY) / scale;

          const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
          scale *= zoomFactor;
          scale = Math.max(minScale, Math.min(5, scale));

          offsetX = mouseX - worldX * scale;
          offsetY = mouseY - worldY * scale;

          constrainPan();
          draw();
        });

        // Touch events for mobile
        let lastTouchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastTouchAngle = 0;
        let touchHasPanned = false;

        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            // Single touch - pan
            isPanning = true;
            touchHasPanned = false;
            const touch = e.touches[0];
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
          } else if (e.touches.length === 2) {
            // Two fingers - pinch zoom and rotate
            isPanning = false;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            lastTouchDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            // Calculate initial angle for rotation
            lastTouchAngle = Math.atan2(
              touch2.clientY - touch1.clientY,
              touch2.clientX - touch1.clientX
            ) * 180 / Math.PI;
          }
        });

        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && isPanning) {
            // Pan with rotation compensation
            const touch = e.touches[0];
            
            // Calculate the movement delta
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            // Check if user has moved enough to count as panning (threshold: 5px)
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
              touchHasPanned = true;
            }
            
            // Rotate the delta based on current rotation
            const rotRad = -rotation * Math.PI / 180;
            const rotatedDeltaX = deltaX * Math.cos(rotRad) - deltaY * Math.sin(rotRad);
            const rotatedDeltaY = deltaX * Math.sin(rotRad) + deltaY * Math.cos(rotRad);
            
            // Apply the rotated delta
            offsetX += rotatedDeltaX;
            offsetY += rotatedDeltaY;
            
            // Update last touch position
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            
            constrainPan();
            draw();
          } else if (e.touches.length === 2) {
            // Pinch zoom and rotate
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            
            // Calculate current angle for rotation
            const currentAngle = Math.atan2(
              touch2.clientY - touch1.clientY,
              touch2.clientX - touch1.clientX
            ) * 180 / Math.PI;

            if (lastTouchDistance > 0) {
              const rect = canvas.getBoundingClientRect();
              const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
              const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;

              const worldX = (centerX - offsetX) / scale;
              const worldY = (centerY - offsetY) / scale;

              // Apply zoom
              const zoomFactor = currentDistance / lastTouchDistance;
              scale *= zoomFactor;
              scale = Math.max(minScale, Math.min(5, scale));

              offsetX = centerX - worldX * scale;
              offsetY = centerY - worldY * scale;

              // Apply rotation
              let angleDelta = currentAngle - lastTouchAngle;
              // Normalize angle to -180 to 180
              if (angleDelta > 180) angleDelta -= 360;
              if (angleDelta < -180) angleDelta += 360;
              rotation += angleDelta;
              
              // Keep rotation in 0-360 range
              rotation = rotation % 360;
              if (rotation < 0) rotation += 360;

              constrainPan();
              draw();
            }

            lastTouchDistance = currentDistance;
            lastTouchAngle = currentAngle;
          }
        });

        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          
          // Check for tap (no panning occurred)
          if (e.touches.length === 0 && !touchHasPanned && isPanning) {
            // Convert the last touch position to a click event for transition button
            const fakeEvent = {
              clientX: lastTouchX,
              clientY: lastTouchY
            };
            checkFloorTransitionClick(fakeEvent);
          }
          
          isPanning = false;
          touchHasPanned = false;
          
          if (e.touches.length < 2) {
            lastTouchDistance = 0;
            lastTouchAngle = 0;
          }
        });
      }

      function zoomIn() {
        scale *= 1.2;
        scale = Math.min(5, scale);
        constrainPan();
        draw();
      }

      function zoomOut() {
        scale *= 0.8;
        scale = Math.max(minScale, scale);
        constrainPan();
        draw();
      }

      function zoomReset() {
        scale = minScale;
        offsetX = (canvas.width - backgroundImage.width * scale) / 2;
        offsetY = (canvas.height - backgroundImage.height * scale) / 2;
        constrainPan();
        draw();
      }

      function rotateLeft() {
        rotation -= 15; // Rotate 15 degrees counter-clockwise
        rotation = rotation % 360;
        if (rotation < 0) rotation += 360;
        draw();
      }

      function rotateRight() {
        rotation += 15; // Rotate 15 degrees clockwise
        rotation = rotation % 360;
        draw();
      }

      function resetRotation() {
        rotation = 0;
        draw();
      }
      
      // ==================== COMPASS FUNCTIONALITY ====================
      let compassSupported = false;
      let currentHeading = 0;
      let compassCalibrated = false;
      let lastHeading = 0;
      let rotationOffset = 0;

      // Initialize compass on page load
      window.addEventListener("load", initCompass);

      function initCompass() {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");
        const compassBtn = document.getElementById("compassBtn");

        // Check if Device Orientation API is supported
        if (window.DeviceOrientationEvent) {
          // For iOS 13+ we need to request permission
          if (
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            compassLabel.textContent = "Tap to enable";
            compassLabel.style.color = "#888";
            compassBtn.style.display = "block"; // Show the button
          } else {
            // Android or older iOS - start automatically
            startCompass();
          }
        } else {
          compassLabel.textContent = "Not supported";
          compassLabel.classList.add("compass-error");
          console.warn("Device Orientation API not supported");
        }
      }

      function enableCompass() {
        const compassBtn = document.getElementById("compassBtn");
        const compassLabel = document.getElementById("compassLabel");

        // Check if permission is needed (iOS 13+)
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          compassBtn.disabled = true;
          compassBtn.textContent = "üß≠ Requesting...";

          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response === "granted") {
                compassBtn.textContent = "‚úÖ Compass Enabled";
                setTimeout(() => {
                  compassBtn.style.display = "none";
                }, 2000);
                startCompass();
              } else {
                compassLabel.textContent = "Permission denied";
                compassLabel.classList.add("compass-error");
                compassBtn.textContent = "‚ùå Permission Denied";
                compassBtn.disabled = false;
              }
            })
            .catch((error) => {
              console.error("Error requesting compass permission:", error);
              compassLabel.textContent = "Permission error";
              compassLabel.classList.add("compass-error");
              compassBtn.textContent = "‚ùå Error";
              compassBtn.disabled = false;
            });
        } else {
          // No permission needed, just start
          startCompass();
          compassBtn.style.display = "none";
        }
      }

      function requestCompassPermission() {
        // This function is kept for backward compatibility with the small button in compass
        enableCompass();
      }

      function startCompass() {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");

        compassSupported = true;
        compassLabel.textContent = "N";
        compassLabel.style.color = "#5f6368";

        // Listen for device orientation changes
        window.addEventListener("deviceorientationabsolute", handleOrientation, true);
        window.addEventListener("deviceorientation", handleOrientation, true);

        // Fallback: if no data received after 3 seconds
        setTimeout(() => {
          if (!compassCalibrated) {
            compassLabel.textContent = "No signal";
            compassLabel.classList.add("compass-error");
          }
        }, 3000);
      }

      function handleOrientation(event) {
        const compassPointer = document.getElementById("compassPointer");
        const compassLabel = document.getElementById("compassLabel");

        let heading = null;

        // Get compass heading
        if (event.webkitCompassHeading !== undefined) {
          // iOS
          heading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
          // Android and other devices
          heading = 360 - event.alpha;
        }

        if (heading !== null) {
          compassCalibrated = true;
          currentHeading = heading;

          // Fix rotation wrapping issue (350¬∞ -> 0¬∞ jump)
          let delta = heading - lastHeading;
          
          // Detect wrap around
          if (delta > 180) {
            // Wrapped from 359 to 0 (going counter-clockwise)
            rotationOffset -= 360;
          } else if (delta < -180) {
            // Wrapped from 0 to 359 (going clockwise)
            rotationOffset += 360;
          }
          
          lastHeading = heading;
          
          // Apply the actual rotation with offset to prevent jumping
          const actualRotation = heading + rotationOffset;
          compassPointer.style.transform = `translate(-50%, -70%) rotate(${actualRotation}deg)`;

          // Update label with cardinal direction
          const direction = getCardinalDirection(heading);
          compassLabel.textContent = direction;
          compassLabel.classList.remove("compass-error");
          compassLabel.style.color = "#5f6368";
        }
      }

      function getCardinalDirection(degrees) {
        const directions = [
          "N",
          "NNE",
          "NE",
          "ENE",
          "E",
          "ESE",
          "SE",
          "SSE",
          "S",
          "SSW",
          "SW",
          "WSW",
          "W",
          "WNW",
          "NW",
          "NNW",
        ];
        const index = Math.round(degrees / 22.5) % 16;
        return directions[index];
      }

      // Optional: Add compass visibility toggle
      function toggleCompass() {
        const compassContainer = document.getElementById("compassContainer");
        if (compassContainer.style.display === "none") {
          compassContainer.style.display = "flex";
        } else {
          compassContainer.style.display = "none";
        }
      }
    </script>
  </body>
</html>
